---
title: "Final Project on BLB"
author: "Lehao Fu"
date: "`r Sys.Date()`"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# 0. Load Useful Packages and Useful Functions
```{r}
library(doParallel)
library(tidyverse)
library(ggplot2)
library(dplyr)
library(viridis)

BLB <- function(data, beta, s, r, u, xi) {
  point_estimate <- u(data)
  n <- length(data)
  b <- round(n^beta)
  xi_star <- vector("list", length = s)
  for (j in 1:s) {
    indices <- sample(x = 1:n, b, replace = FALSE)
    u_star <- numeric(r)
    for (k in 1:r) {
      resample <- sample(indices, n, replace = TRUE)
      u_star[k] <- u(data[resample])
    }
    xi_star[[j]] <- xi(u_star - point_estimate, point_estimate)
  }
  # for (j in 1:s) {
  #   print(xi_star[[j]])
  # }
  # compute average values of xi computed for different data subsets
  average <- numeric(2)
  for (i in 1:s) {
    average <- average + xi_star[[i]]
  }
  average <- average / s
  return(average)
}

ScaSub <- function(data, beta, c1, u, xi) {
  point_estimate <- u(data)
  n <- length(data)
  b <- round(n^beta)
  h <- round(c1*b)
  q <- floor((n-b)/h) + 1
  u_star <- numeric(q)
  for (i in 1:q) {
    u_star[i] <- u(data[((i-1)*h + 1):((i-1)*h + b)])
  }
  root_dist <- sqrt(b / n) * (u_star - point_estimate)
  return(xi(root_dist, point_estimate))
}

BLBpar <- function(data, beta, s, r, u, xi) {
  point_estimate <- u(data)
  n <- length(data)
  b <- round(n^beta)
  
  # use multi-cores to conduct parallel computing
  # ncores <- min(6, detectCores())
  ncores <- detectCores() - 1
  cl <- makeCluster(ncores)
  registerDoParallel(cl)
  
  # Ensure cluster is stopped on exit
  on.exit({
    stopCluster(cl)
    registerDoSEQ()  # Reset to sequential backend
  }, add = TRUE)
  
  xi_star <- foreach (j = 1:s) %dopar%{
    indices <- sample(x = 1:n, b, replace = FALSE)
    u_star <- numeric(r)
    for (k in 1:r) {
      resample <- sample(indices, n, replace = TRUE)
      u_star[k] <- u(data[resample])
    }
    xi(u_star - point_estimate, point_estimate)
  }
  
  # close the cluster
  # on.exit({
  #   stopCluster(cl)
  #   registerDoSEQ()
  # })
  
  average <- numeric(2)
  for (i in 1:s) {
    average <- average + xi_star[[i]]
  }
  average <- average / s
  return(average)
}

generate.1dim <- function(sample.size, dist.type){
  n = sample.size
  if(dist.type == "F"){
    samples = rf(n = n, df1 = 10, df2 = 10)
  }else if(dist.type == "normal"){
    samples = rnorm(n = n, mean = 0, sd = 1)
  }else if(dist.type == "mixed Gaussians"){
    group <- rbinom(n, 1, 0.5)
    samples = ifelse(group == 1,
                     rnorm(n, mean = 0, sd = 1),
                     rnorm(n, mean = 5, sd = 1))
  }
}

create_tibble.fix_n <- function(beta_seq, num_repeat) {
  n = length(beta_seq) * num_repeat
  tibble(
    beta = numeric(n),
    BLB_length = numeric(n),
    BLB_contain = logical(n),
    ScaSub_length = numeric(n),
    ScaSub_contain = logical(n)
  )
}

create_tibble.fix_beta <- function(beta_seq, num_repeat, n_seq){
  num.rows = length(beta_seq) * num_repeat * length(n_seq)
  tibble(
    sample.size = numeric(num.rows),
    beta = numeric(num.rows),
    BLB_length = numeric(num.rows),
    BLB_contain = logical(num.rows),
    ScaSub_length = numeric(num.rows),
    ScaSub_contain = logical(num.rows)
  )  
}

my_xi <- function(x, point_estimate) {
  interval <- point_estimate - quantile(x, probs = c(0.975, 0.025))
  names(interval) <- names(interval)[2:1]
  return(interval)
}

plot_beta.coverage <- function(result) {
  result_summary <- result %>%
    group_by(beta) %>%
    summarize(
      BLB_contain_mean = mean(BLB_contain),
      ScaSub_contain_mean = mean(ScaSub_contain),
      BLB_length_mean = mean(BLB_length),
      ScaSub_length_mean = mean(ScaSub_length)
    )

  result_long <- result_summary %>%
    pivot_longer(
      cols = c(BLB_contain_mean, ScaSub_contain_mean),
      names_to = "Method",
      values_to = "Coverage Proportion"
    )

  p <- ggplot(result_long, aes(x = beta, y = `Coverage Proportion`, color = Method, linetype = Method, group = Method)) +
    geom_line(linewidth = 1) +  # Update to use linewidth
    geom_point(size = 2) +
    scale_color_viridis_d(
      begin = 0.2, end = 0.8, option = "C",
      labels = c("BLB", "ScaSub")
    ) +
    scale_linetype_manual(
      values = c("solid", "dashed"),
      labels = c("BLB", "ScaSub")
    ) +
    labs(
      title = "Coverage Proportion by Method for Different Beta",
      x = "Beta",
      y = "Coverage Proportion",
      color = "Method",
      linetype = "Method"
    ) +
    scale_y_continuous(limits = c(0, 1)) +  # Set y-axis range
    theme_minimal() +
    theme(
      text = element_text(size = 12),
      plot.title = element_text(hjust = 0.5),
      legend.position = "right"
    )

  return(p)
}


plot_beta.CI_length <- function(result) {
  result_summary <- result %>%
    group_by(beta) %>%
    summarize(
      # Calculate the mean CI length for each method
      BLB_length_mean = mean(BLB_length),
      ScaSub_length_mean = mean(ScaSub_length)
    )

  # Convert to long format for ggplot
  result_long <- result_summary %>%
    pivot_longer(
      cols = c(BLB_length_mean, ScaSub_length_mean),
      names_to = "Method",
      values_to = "CI Length"
    )

  # Create the plot
  p <- ggplot(result_long, aes(x = beta, y = `CI Length`, color = Method, linetype = Method, group = Method)) +
    geom_line(linewidth = 1) +  # Draw lines
    geom_point(size = 2) + # Add points
    scale_color_viridis_d(
      begin = 0.2, end = 0.8, option = "C",  # Define color scale
      labels = c("BLB", "ScaSub")
    ) +
    scale_linetype_manual(
      values = c("solid", "dashed"),  # Define line types
      labels = c("BLB", "ScaSub")
    ) +
    labs(
      title = "Average CI Length by Method for Different Beta",
      x = "Beta",
      y = "Average CI Length",
      color = "Method",
      linetype = "Method"
    ) +
    theme_minimal() +
    theme(
      text = element_text(size = 12),
      plot.title = element_text(hjust = 0.5),
      legend.position = "right"
    )

  return(p)
}

# Function to plot coverage vs. sample size for different methods
plot_sample_size_coverage <- function(result) {
  # Data preprocessing: Calculate average coverage for each combination of sample size and beta
  result_summary <- result %>%
    group_by(sample.size, beta) %>%
    summarize(
      BLB_coverage = mean(BLB_contain, na.rm = TRUE), # Average coverage for BLB
      ScaSub_coverage = mean(ScaSub_contain, na.rm = TRUE), # Average coverage for ScaSub
      .groups = "drop"
    ) %>%
    pivot_longer(
      cols = c(BLB_coverage, ScaSub_coverage), # Convert wide format to long format
      names_to = "MethodType", # Create a column for the method type (BLB or ScaSub)
      values_to = "Coverage" # Create a column for the coverage value
    ) %>%
    mutate(
      Method = paste0(ifelse(MethodType == "BLB_coverage", "BLB", "SS"), "-", beta) # Create unique labels for each line
    )
  
  # Manually define colors and line types for each method
  line_colors <- c("BLB-0.5" = "#FF7F0E", "BLB-0.7" = "#9467BD", "BLB-0.9" = "#17BECF", "SS-0.5" = "#FF7F0E", "SS-0.7" = "#9467BD", "SS-0.9" = "#17BECF")
  line_types <- c("BLB-0.5" = "solid", "BLB-0.7" = "solid", "BLB-0.9" = "solid",
                  "SS-0.5" = "dashed", "SS-0.7" = "dashed", "SS-0.9" = "dashed")
  
  # Plotting the coverage vs. sample size
  ggplot(result_summary, aes(x = sample.size, y = Coverage, group = Method)) +
    geom_line(aes(color = Method, linetype = Method), linewidth = 1) + # Draw lines with specific aesthetics
    geom_point(aes(color = Method), size = 2) + # Add points with specific colors
    labs(
      title = "Coverage vs. Sample Size for Different Methods", # Title of the plot
      x = "Sample Size (log scale)", # Label for the x-axis
      y = "Coverage", # Label for the y-axis
      color = "Method", # Unified legend title
      linetype = "Method" # Unified legend title
    ) +
    scale_color_manual(values = line_colors) + # Manually set line colors
    scale_linetype_manual(values = line_types) + # Manually set line types
    scale_x_log10() + # Set x-axis to logarithmic scale
    coord_cartesian(ylim = c(0, 1)) + # Set y-axis limits from 0 to 1
    theme_minimal() + # Use a clean, minimal theme
    theme(
      text = element_text(size = 12), # Set font size
      plot.title = element_text(hjust = 0.5), # Center-align the title
      legend.position = "right" # Place the legend on the right
    )
}
```

# 1. Compare the convergence of BLB and subsampling
```{r}
set.seed(0)
n = 1000; MC.iters = 1000; num_repeat = 100
dist.type_seq = c("F", "normal", "mixed Gaussians")
# dist.type_seq = c("F")
true_param_seq = c(1, 0, 2.5) # F(10, 10), N(0, 1), 0.5N(0, 1)+0.5N(5, 1)
beta_seq = seq(from = 0.5, to = 0.9, by = 0.1)

# for loop for different distribution
for(dist.type.i in 1:length(dist.type_seq)){
  dist.type = dist.type_seq[dist.type.i]
  true_param = true_param_seq[dist.type.i]
  result = create_tibble.fix_n(beta_seq = beta_seq, num_repeat = num_repeat)
  cat("Now conducting the simulation for distribution =", dist.type, ":\n")
  
  # for loop for different beta
  for(beta.i in 1:length(beta_seq)) {
    beta = beta_seq[beta.i]
    cat("Now conducting the simulation for beta =", beta, ":\n")
    
    # for loop for repeats
    for (i in 1:num_repeat) {
      if(i %% 50 == 0) cat("Now running", i, " iterations...\n")
      random.samples <- generate.1dim(sample.size = n, dist.type = dist.type)
      BLB_interval <- BLBpar(random.samples, beta = beta, s = 8, r = MC.iters, u = median, xi = my_xi)
      ScaSub_interval <- ScaSub(random.samples, beta = beta, c1 = 0.5, u = median, xi = my_xi)
  
      result$beta[(beta.i - 1) * num_repeat + i] <- beta
      result$BLB_length[(beta.i - 1) * num_repeat + i] <- BLB_interval[2] - BLB_interval[1]
      result$BLB_contain[(beta.i - 1) * num_repeat + i] <- (BLB_interval[1] <= true_param) && (BLB_interval[2] >= true_param)
      result$ScaSub_length[(beta.i - 1) * num_repeat + i] <- ScaSub_interval[2] - ScaSub_interval[1]
      result$ScaSub_contain[(beta.i - 1) * num_repeat + i] <- (ScaSub_interval[1] <= true_param) && (ScaSub_interval[2] >= true_param)
    }
  }
  
  # plot figures and save them to the output
  p1 = plot_beta.coverage(result)
  
  ggsave(paste0("output/figures/", dist.type, ".beta_coverage.png"), p1, 
        width = 8, height = 6, dpi = 300,  # Set size and resolution
        bg = "white")
  p2 = plot_beta.CI_length(result)
  ggsave(paste0("output/figures/", dist.type, ".beta_CI_length.png"), p2, 
        width = 8, height = 6, dpi = 300,  # Set size and resolution
        bg = "white")
}
```

# 2. Compare the covergence rate of two methods with the increase of sample size n
```{r}
set.seed(0)
MC.iters = 1000; num_repeat = 100
dist.type_seq = c("F", "normal", "mixed Gaussians")
# dist.type_seq = c("mixed Gaussians"); true_param_seq = c(2.5)
true_param_seq = c(1, 0, 2.5) # F(10, 10), N(0, 1), 0.5N(0, 1)+0.5N(5, 1)
n_seq = c(50, 100, 500, 1000, 5000, 10000)
# n_seq = c(5, 50, 500)
beta_seq = seq(from = 0.5, to = 0.9, by = 0.2)

# for loop for different distribution
for(dist.type.i in 1:length(dist.type_seq)){
  dist.type = dist.type_seq[dist.type.i]
  true_param = true_param_seq[dist.type.i]
  result = create_tibble.fix_beta(beta_seq = beta_seq, num_repeat = num_repeat, n_seq = n_seq)
  cat("Now conducting the simulation for distribution =", dist.type, "...\n")
  
  # for loop for different beta
  for(n.i in 1:length(n_seq)){
    n = n_seq[n.i]
    cat("Now conducting the simulation for n =", n, "...\n")
    for(beta.i in 1:length(beta_seq)) {
      beta = beta_seq[beta.i]
      cat("Now conducting the simulation for beta =", beta, "...\n")
      
      # for loop for repeats
      for (i in 1:num_repeat) {
        if(i %% 50 == 0) cat("Now running", i, " iterations...\n")
        random.samples <- generate.1dim(sample.size = n, dist.type = dist.type)
        BLB_interval <- BLBpar(random.samples, beta = beta, s = 8, r = MC.iters, u = median, xi = my_xi)
        ScaSub_interval <- ScaSub(random.samples, beta = beta, c1 = 0.5, u = median, xi = my_xi)
        
        result$sample.size[(n.i - 1) * length(beta_seq) * num_repeat + (beta.i - 1) * num_repeat + i] = n
        result$beta[(n.i - 1) * length(beta_seq) * num_repeat + (beta.i - 1) * num_repeat + i] <- beta
        result$BLB_length[(n.i - 1) * length(beta_seq) * num_repeat + (beta.i - 1) * num_repeat + i] <- BLB_interval[2] - BLB_interval[1]
        result$BLB_contain[(n.i - 1) * length(beta_seq) * num_repeat + (beta.i - 1) * num_repeat + i] <- (BLB_interval[1] <= true_param) && (BLB_interval[2] >= true_param)
        result$ScaSub_length[(n.i - 1) * length(beta_seq) * num_repeat + (beta.i - 1) * num_repeat + i] <- ScaSub_interval[2] - ScaSub_interval[1]
        result$ScaSub_contain[(n.i - 1) * length(beta_seq) * num_repeat + (beta.i - 1) * num_repeat + i] <- (ScaSub_interval[1] <= true_param) && (ScaSub_interval[2] >= true_param)
      }
    }
  }
  
  # plot figures and save them to the output
  p1 = plot_sample_size_coverage(result)

  ggsave(paste0("output/figures/change n & fix beta/", dist.type, ".n_coverage.png"), p1,
        width = 8, height = 6, dpi = 300,  # Set size and resolution
        bg = "white")
}
```



